## 항해 Chapter2 서버구축 회고록

### 2-1 시나리오 선택, 개발환경 준비, 시나리오 분석 및 작업계획
시나리오를 이커머스로 선정하고 요구사항을 분석했다.  
프로젝트 시작단계에 필요한 마일스톤, 시퀀스 다이어그램, 플로우차트, ERD, API명세, MOCK API를 만들었다.
ERD 말고는 다 처음 해보는 것들이라 익숙하지 않았다.  
1, 2주차를 거치며 요구사항을 분석 후 개발하는 것이 중요하다는 걸 깨달았지만, 나는 코드를 작성하며 동시에 생각하는 방식에 익숙했기 때문에 그게 힘들었다.   
그래서 특히 시퀀스 다이어그램, 플로우차트를 그리는게 어려웠다.  
그렇지만 부족하더라도 다 완성하고 나니 요구사항에 대해 더 명확하게 이해할 수 있었고, 
작업을 진행하는 데 참조할 수 있는 문서가 있어 안정감을 느낄 수 있었다.


## 2-2 비즈니스 로직, 유스케이스 개발 및 테스트
요구사항 API 들에 대해 TDD를 하며 전체 로직을 완성해야 했다.    
사전 스터디부터 TDD를 했지만 TDD 원칙을 지키며 코드를 짜는건 정말 어려웠다. 나는 코드를 짠 뒤 테스트를 작성하는 형식으로 진행했다.  
내가 설계한 내용을 유지하며, DDD를 지키려고 했지만 이 과정에서 많은 시행착오가 있었다.  
하나는 주문 -> 결제 흐름을 하나의 메서드에서 이어지도록 했는데, 메서드가 너무 커지고 책임 분리가 전혀 되지 않았다.   
또 하나는 쿠폰, 주문 등 상세한 부분들을 잡고 싶었는데, 아직 능력이 부족하다 느꼈다..  
그리고 DDD를 지키려고 도메인 객체와 JPA Entity를 구분했는데, 계층간 변환으로 인해 비관적 락을 사용할때 JPA 영속성 이 깨져 동시성 제어가 전혀 되지 않았다.  
이런 문제들이 하나 하나 쌓이니 이 주차의 과제는 제대로 못한것같다..


## 2-3 로깅, 예외처리, 필터, 인터셉터, 기능개선
프로젝트의 공통 처리를 담당하는 부분을 구현하고, 전 주차의 부족했던 기능들을 개선하려 했다.
커스텀 예외는 만들지 않고, 에러 코드만 각각 정의해 globalExceptionHandler로 모든 예외를 처리해보도록 했다.
필터, 인터셉터는 현재 프로젝트에 요청/응답 로깅을 찍는 것 말고는 딱히 적용할 게 없어 보였는데.. 로깅에 대해 추가할 만 한 것들을 몇개 추가해보았다.

전 주차에서 가장 큰 문제는 도메인 객체와 JPA Entity의 구분이었다.
도메인 객체와 JPA Entity 를 나눈다면, 도메인 객체의 로직을 JPA Entity 가 사용해야만 했고, 그렇지 않다면 도메인에서 JPA Entity 를 아는 꼴이 되었다.
그래서 모든 도메인 객체를 JPA에 의존성을 두도록 변경했는데, 이 과정에서 기존 작성한 코드, 테스트 코드들이 다 깨졌다..

## 항해 Chapter2 서버구축 회고록

### 2-1 시나리오 선택, 개발환경 준비, 시나리오 분석 및 작업계획
시나리오를 이커머스로 선정하고 요구사항을 분석했다.  
프로젝트 시작단계에 필요한 마일스톤, 시퀀스 다이어그램, 플로우차트, ERD, API명세, MOCK API를 만들었다.
ERD 말고는 다 처음 해보는 것들이라 익숙하지 않았다.  
1, 2주차를 거치며 요구사항을 분석 후 개발하는 것이 중요하다는 걸 깨달았지만, 나는 코드를 작성하며 동시에 생각하는 방식에 익숙했기 때문에 그게 힘들었다.   
그래서 특히 시퀀스 다이어그램, 플로우차트를 그리는게 어려웠다.  
그렇지만 부족하더라도 다 완성하고 나니 요구사항에 대해 더 명확하게 이해할 수 있었고,
작업을 진행하는 데 참조할 수 있는 문서가 있어 안정감을 느낄 수 있었다.


## 2-2 비즈니스 로직, 유스케이스 개발 및 테스트
요구사항 API 들에 대해 TDD를 하며 전체 로직을 완성해야 했다.  
사전 스터디부터 TDD를 했지만 TDD 원칙을 지키며 코드를 짜는건 정말 어려웠다. 나는 코드를 짠 뒤 테스트를 작성하는 형식으로 진행했다.  
내가 설계한 내용을 지키며, DDD를 지키려고 했지만 그 부분들에서 많은 시행착오가 있었다.  
하나는 주문 -> 결제가 하나의 메서드에서 이어지도록 했는데, 그 부분을 담당하는 메서드가 너무 커지고 책임 분리가 전혀 되지 않았다.  
또 하나는 쿠폰, 주문 등 상세한 부분들을 잡고 싶었는데, 내 능력이 아직 부족하다 느꼈다.    
그리고 DDD를 지키려고 도메인 객체와 JPA Entity를 구분했는데, 계층간 변환으로 인해 비관적 락을 사용할때 JPA 영속성 이 깨져 동시성 제어가 되지 않았다.  
이런 문제들이 하나 하나 쌓이니 어디부터 얼마나 고쳐야할지 판단도 잘 안되고, 제대로 진행이 안됬었다..


## 2-3 로깅, 예외처리, 필터, 인터셉터, 기능개선
프로젝트의 공통 처리를 담당하는 로직들을 구현하고, 전 주차의 못했던 부분들을 기능개선 하려 했다.  
나는 커스텀 예외는 만들지 않고, 에러 코드만 각각 정의해 globalExceptionHanlder로 모든 예외를 처리하려 해보았다.  
필터, 인터셉터는 현재 프로젝트에 요청/응답 로깅을 찍는 것 말고는 딱히 적용할 게 없어 보였는데, 로깅에 대해 추가할 만 한 것들을 몇개 추가해보았다.

전 주차에서 가장 큰 문제는 도메인 객체와 JPA Entity의 구분이었다.
도메인 객체와 JPA Entity 를 나눈다면 도메인 객체의 로직을 JPA Entity 가 사용해야만 했고, 그렇지 않다면 도메인에서 JPA Entity 를 아는 꼴이 되었다.  
그래서 모든 도메인 객체를 JPA에 의존성을 두도록 변경했는데, 이 과정에서 기존 작성한 코드, 테스트 코드들이 다 깨졌다.. 프로젝트를 갈아 엎는 정도의 수정이 필요했다.  
Entity의 연관관계도 다 끊었다. ManyToOne을 사용하면, NO_CONSTRAINT을 쓰더라도 도메인 안에 다른 도메인이 있었는데, 이것도 DDD가 깨진다고 생각했고, 내 능력으로 연관관계를 사용하며 진행하기 힘들다고 판단했다.  
주문 -> 결제의 흐름도, 내 능력에는 API를 나눠 진행하는 것이 낫다고 생각해 그렇게 진행했다.  
이번 경험을 통해 유연하게 설계를 하는 것에 중요성을 크게 느꼈고, 자기객관화가 많이 필요하다고 느꼈다.
